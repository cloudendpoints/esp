// Copyright (C) Extensible Service Proxy Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////////
//
#include "src/api_manager/auth/authz_cache.h"
#include "gtest/gtest.h"

namespace google {
namespace api_manager {
namespace auth {
namespace {

const std::string kPath = "/path/to/resource";
const std::string kPath1 = "path/to/resources";
const std::string kHTTPMethod = "GET";
const std::string kAuthToken =
    "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiI2Mjg2NDU3NDE4ODEtbm9hYml1M"
    "jNmNWE4bThvdmQ4dWN2Njk4bGo3OHZ2MGxAZGV2ZWxvcGVyLmdzZXJ2aWNlYWNjb3VudC5jb20"
    "iLCJzdWIiOiI2Mjg2NDU3NDE4ODEtbm9hYml1MjNmNWE4bThvdmQ4dWN2Njk4bGo3OHZ2MGxAZ"
    "GV2ZWxvcGVyLmdzZXJ2aWNlYWNjb3VudC5jb20iLCJhdWQiOiJodHRwOi8vbXlzZXJ2aWNlLmN"
    "vbS9teWFwaSJ9.gq_4ucjddQDjYK5FJr_kXmMo2fgSEB6Js1zopcQLVpCKFDNb-TQ97go0wuk5"
    "_vlSp_8I2ImrcdwYbAKqYCzcdyBXkAYoHCGgmY-v6MwZFUvrIaDzR_M3rmY8sQ8cdN3MN6ZRbB"
    "6opHwDP1lUEx4bZn_ZBjJMPgqbIqGmhoT1UpfPF6P1eI7sXYru-4KVna0STOynLl3d7JYb7E-8"
    "ifcjUJLhat8JR4zR8i4-zWjn6d6j_NI7ZvMROnao77D9YyhXv56zfsXRatKzzYtxPlQMz4AjP-"
    "bUHfbHmhiIOOAeEKFuIVUAwM17j54M6VQ5jnAabY5O-ermLfwPiXvNt2L2SA==";
const int kAuthzCacheTimeout = 300;
const std::chrono::system_clock::time_point now =
    std::chrono::system_clock::now();
const std::string cache_key =
    AuthzCache::ComposeAuthzCacheKey(kAuthToken, kPath, kHTTPMethod);
const std::string new_cache_key =
    AuthzCache::ComposeAuthzCacheKey(kAuthToken, kPath1, kHTTPMethod);

class TestAuthzCache : public ::testing::Test {
 public:
  virtual void SetUp() {}
  AuthzCache cache_;
};

// Key generated by MD5 hash algorihtm is of fixed length. Different
// combinations of key components result in different keys.
TEST_F(TestAuthzCache, KeyGeneration) {
  ASSERT_EQ(cache_key.length(), 16);
  ASSERT_EQ(new_cache_key.length(), 16);
  ASSERT_NE(cache_key, new_cache_key);
}

// Lookup the cache entry that does not exist.
TEST_F(TestAuthzCache, EntryNotExist) {
  AuthzValue val;
  ASSERT_FALSE(cache_.Lookup(cache_key, now, &val));
  ASSERT_EQ(cache_.NumberOfEntries(), 0);
  cache_.Add(cache_key, true, now);
  ASSERT_EQ(cache_.NumberOfEntries(), 1);
  ASSERT_FALSE(cache_.Lookup(new_cache_key, now, &val));
  ASSERT_EQ(cache_.NumberOfEntries(), 1);
}

// Lookup the cache entry that has expired. In this case, Lookup also deletes
// expired entry.
TEST_F(TestAuthzCache, EntryExistButExpired) {
  cache_.Add(cache_key, true, now - std::chrono::seconds(kAuthzCacheTimeout));
  ASSERT_EQ(cache_.NumberOfEntries(), 1);
  AuthzValue val;
  ASSERT_FALSE(cache_.Lookup(
      cache_key, now + std::chrono::seconds(kAuthzCacheTimeout), &val));
  ASSERT_EQ(cache_.NumberOfEntries(), 0);
}

// Lookup the cache entry that has not expired.
TEST_F(TestAuthzCache, EntryExistNotExpired) {
  cache_.Add(cache_key, true, now);
  ASSERT_EQ(cache_.NumberOfEntries(), 1);
  AuthzValue val;
  ASSERT_TRUE(cache_.Lookup(cache_key, now, &val));
  ASSERT_EQ(cache_.NumberOfEntries(), 1);
  ASSERT_EQ(val.if_success, true);
  ASSERT_EQ(val.exp, now + std::chrono::seconds(kAuthzCacheTimeout));
}

}  // namespace
}  // namespace auth
}  // namespace api_manager
}  // namespace google
