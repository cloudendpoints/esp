// Copyright (C) Extensible Service Proxy Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////////
//
#include "src/api_manager/auth/authz_cache.h"
#include "gtest/gtest.h"

namespace google {
namespace api_manager {
namespace auth {
namespace {

const std::string kPath = "/path/to/resource";
const std::string kPath1 = "path/to/resources";
const std::string kHTTPMethod = "GET";
const std::string kAuthToken =
    "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiI2Mjg2NDU3NDE4ODEtbm9hYml1M"
    "jNmNWE4bThvdmQ4dWN2Njk4bGo3OHZ2MGxAZGV2ZWxvcGVyLmdzZXJ2aWNlYWNjb3VudC5jb20"
    "iLCJzdWIiOiI2Mjg2NDU3NDE4ODEtbm9hYml1MjNmNWE4bThvdmQ4dWN2Njk4bGo3OHZ2MGxAZ"
    "GV2ZWxvcGVyLmdzZXJ2aWNlYWNjb3VudC5jb20iLCJhdWQiOiJodHRwOi8vbXlzZXJ2aWNlLmN"
    "vbS9teWFwaSJ9.gq_4ucjddQDjYK5FJr_kXmMo2fgSEB6Js1zopcQLVpCKFDNb-TQ97go0wuk5"
    "_vlSp_8I2ImrcdwYbAKqYCzcdyBXkAYoHCGgmY-v6MwZFUvrIaDzR_M3rmY8sQ8cdN3MN6ZRbB"
    "6opHwDP1lUEx4bZn_ZBjJMPgqbIqGmhoT1UpfPF6P1eI7sXYru-4KVna0STOynLl3d7JYb7E-8"
    "ifcjUJLhat8JR4zR8i4-zWjn6d6j_NI7ZvMROnao77D9YyhXv56zfsXRatKzzYtxPlQMz4AjP-"
    "bUHfbHmhiIOOAeEKFuIVUAwM17j54M6VQ5jnAabY5O-ermLfwPiXvNt2L2SA==";
const int kAuthzCacheTimeout = 300;

class TestAuthzCache : public ::testing::Test {
 public:
  void SetUp() {
    now_ = std::chrono::system_clock::now();
    cache_key_ =
        AuthzCache::ComposeAuthzCacheKey(kAuthToken, kPath, kHTTPMethod);
    new_cache_key_ =
        AuthzCache::ComposeAuthzCacheKey(kAuthToken, kPath1, kHTTPMethod);
  }

  AuthzCache cache_;
  std::chrono::system_clock::time_point now_;
  std::string cache_key_;
  std::string new_cache_key_;
};

// Key generated by MD5 hash algorihtm is of fixed length. Different
// combinations of key components result in different keys.
TEST_F(TestAuthzCache, KeyGeneration) {
  ASSERT_EQ(cache_key_.length(), 16);
  ASSERT_EQ(cache_key_, " [\x9A\r\xC4\xE1I5\xA6\xDD\x92\xFD\x1A-\xCDT");
  ASSERT_EQ(new_cache_key_.length(), 16);
  ASSERT_EQ(new_cache_key_, "\v\xD6\xC3\xD9\x84\"\xF1\x81\xC4\xC5=\x81T^\xDC?");
  ASSERT_NE(cache_key_, new_cache_key_);
}

// Lookup the cache entry that does not exist.
TEST_F(TestAuthzCache, EntryNotExist) {
  AuthzValue val;
  ASSERT_FALSE(cache_.Lookup(cache_key_, now_, &val));
  ASSERT_EQ(cache_.NumberOfEntries(), 0);
  cache_.Add(cache_key_, true, now_);
  ASSERT_EQ(cache_.NumberOfEntries(), 1);
  ASSERT_FALSE(cache_.Lookup(new_cache_key_, now_, &val));
  ASSERT_EQ(cache_.NumberOfEntries(), 1);
}

// Lookup the cache entry that has expired. In this case, Lookup also deletes
// expired entry.
TEST_F(TestAuthzCache, EntryExistButExpired) {
  cache_.Add(cache_key_, true,
             now_ - std::chrono::seconds(2 * kAuthzCacheTimeout));
  ASSERT_EQ(cache_.NumberOfEntries(), 1);
  AuthzValue val;
  ASSERT_FALSE(cache_.Lookup(cache_key_, now_, &val));
  ASSERT_EQ(cache_.NumberOfEntries(), 0);
}

// Lookup the cache entry that has not expired.
TEST_F(TestAuthzCache, EntryExistNotExpired) {
  cache_.Add(cache_key_, true, now_);
  ASSERT_EQ(cache_.NumberOfEntries(), 1);
  AuthzValue val;
  ASSERT_TRUE(cache_.Lookup(cache_key_, now_, &val));
  ASSERT_EQ(cache_.NumberOfEntries(), 1);
  ASSERT_EQ(val.if_success, true);
}

}  // namespace
}  // namespace auth
}  // namespace api_manager
}  // namespace google
