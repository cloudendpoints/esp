#!/bin/bash
#
# Copyright (C) Extensible Service Proxy Authors
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
################################################################################
#

if [[ "$(uname)" != "Linux" ]]; then
  echo "Run on Linux only."
  exit 1
fi

COVERAGE_TAR=esp-code-coverage.tar.gz
COVERAGE_SUMMARY=esp-code-coverage.summary
TEST_WORKSPACE='__main__'

while getopts dms:t: arg; do
  case ${arg} in
    d) echo "-d is deprecated and a noop";;
    m) echo "-m is deprecated and a noop";;
    s) COVERAGE_SUMMARY=${OPTARG};;
    t) COVERAGE_TAR=${OPTARG};;
    ?) exit 1;
  esac
done

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
. ${ROOT}/script/all-utilities || { echo "Cannot load Bash utilities"; exit 1; }


function header() {
  echo '********************************************************************************'
  echo "${@}"
  echo '********************************************************************************'
}

cd "${ROOT}"
${BAZEL} ${BAZEL_ARGS} clean
${ROOT}/script/obliterate
echo "Running code coverage build."
retry -n 3 ${BAZEL} ${BAZEL_ARGS} fetch //src/... \
  && retry -n 2 ${BAZEL} ${BAZEL_ARGS} build ${BAZEL_BUILD_ARGS} \
  --collect_code_coverage \
  --instrumentation_filter '' //src/... \
  || error_exit 'Cannot build targets.'

# Run all unit tests. They are tests defined by query
# ${BAZEL} ${BAZEL_ARGS} query 'tests(//src/...) - tests(//src/nginx/t/...)'
#
# Bazel returns the test targets as, for example:
#   //src/api_manager:http_template_test
# so we strip the leading double-slash and replace any colons with
# a forward slash to create the tests'relative path under bazel-bin.
while read test; do
  header "${ROOT}/bazel-bin/${test}"
  ${ROOT}/bazel-bin/${test} \
    || error_exit "${ROOT}/bazel-bin/${test} failed."
done < <(
    ${BAZEL} ${BAZEL_ARGS} query 'tests(//src/...) - tests(//src/nginx/t/...)' \
      | sed -e 's|^//||' -e 's|:|/|' \
      | sort
    )

# Run the ESP integration tests.
#
# We set "master_process off;" to make sure NGINX runs in a single
# process (running with workers corrupts the code coverage output).
# And we point at the nginx-esp binary.
while IFS=':' read package test; do
  # Strip leading // from the package name.
  package=${package##//}
  header "${ROOT}/bazel-bin/${package}/${test}"

  # Create a symbolic link to bazel-out.
  #
  # Binaries generated by Bazel output coverage information in the relative
  # directory bazel-out/... but because support for code coverage in Bazel
  # is not complete, we need to point the bazel-out directory where Bazel
  # wants to write to the actual bazel-out directory where tools later
  # expect to find coverage data results.
  ln -s $(readlink "${ROOT}/bazel-out") \
    "${ROOT}/bazel-bin/${package}/${test}.runfiles/${TEST_WORKSPACE}/bazel-out" \
    || error_exit "Cannot create a symlink."

  # Run the test.
  TEST_NGINX_GLOBALS='master_process off;' \
    "${ROOT}/bazel-bin/${package}/${test}" \
    || error_exit "${ROOT}/bazel-bin/${package}/${test} failed."
done < <(
    ${BAZEL} ${BAZEL_ARGS} query 'tests(//src/nginx/t/...)' \
      | sort
    )

lcov --capture --directory=${ROOT}/bazel-out --follow \
     --base-directory=${ROOT}/bazel-${ROOT##*/} \
     --output-file=esp-code-coverage-full.info \
  || error_exit "Failed to capture code coverage data."

lcov --extract esp-code-coverage-full.info "${ROOT}/bazel-${ROOT##*/}/src/*" \
     --output-file=esp-code-coverage.info \
  || error_exit "Failed to extract ESP subset of code coverage."

lcov --summary esp-code-coverage.info > ${COVERAGE_SUMMARY} 2>&1 \
  || error_exit "Failed to generate coverage summary."

genhtml esp-code-coverage.info --output-directory=esp-code-coverage \
  || error_exit "Failed to generate coverage HTML."

tar -zcf ${COVERAGE_TAR} esp-code-coverage \
  || error_exit "Failed to create coverage tar file \"${COVERAGE_TAR}\"."

# Ouptut code coverage info into the log.
lcov --list esp-code-coverage.info

echo "Code Coverage build complete."
